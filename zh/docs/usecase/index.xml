<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>功能设计 on</title><link>https://n9e.github.io/zh/docs/usecase/</link><description>Recent content in 功能设计 on</description><generator>Hugo -- gohugo.io</generator><language>en-US</language><lastBuildDate>Fri, 06 Jun 2025 10:41:08 +0800</lastBuildDate><atom:link href="https://n9e.github.io/zh/docs/usecase/index.xml" rel="self" type="application/rss+xml"/><item><title>业务组</title><link>https://n9e.github.io/zh/docs/usecase/bizgroup/</link><pubDate>Fri, 13 Jun 2025 10:14:48 +0800</pubDate><guid>https://n9e.github.io/zh/docs/usecase/bizgroup/</guid><description>夜莺中要管理很多东西，比如：告警规则、屏蔽规则、订阅规则、自愈脚本、仪表盘，在创建这些东西的时候，都要先选择一个业务组，因为这些东西都要归属到某个业务组。还有机器也是，安装了 categraf 之后，categraf 就会自动向夜莺注册机器信息，此时这个机器会出现在未归组机器列表种，管理员需要把这个机器归到某个业务组下，业务组的人才能使用。
业务组在夜莺中使用频繁，本篇讲解夜莺监控中的业务组的概念，以及相关的设计初衷。
需求来源 # 夜莺中要管理很多东西，比如：告警规则、屏蔽规则、订阅规则、自愈脚本、机器等。如果各个东西都放在一个表格里让大家查看、管理，那就比较混乱了，需要有个机制来分门别类。
于是，我们引入了“业务组”的概念。业务组就是一个分组机制，比如 DBA 把 MySQL 的告警规则放到一个业务组里（组名姑且叫 DBA/MySQL），把 Postgres 的告警规则放到另一个业务组里（组名姑且叫 DBA/Postgres）；比如 Kubernetes 运维人员，按照集群对 Kubernetes 的宿主机做了拆分，不同的集群的机器放到不同的业务组下，比如分成 K8S/集群A、K8S/集群B 等等。
演进 # 早期版本的夜莺，业务组渲染为扁平的列表，后来发现，其实业务组需要层级结构，比如上面的四个业务组：
DBA/MySQL DBA/Postgres K8S/集群A K8S/集群B 渲染为树形结构的话就更方便查看：
DBA ├── MySQL └── Postgres K8S ├── 集群A └── 集群B 所以新版本的夜莺，为了兼容老版本，业务组存储到 DB 的时候，仍然是扁平的列表，但在前端展示的时候，可以根据名称里的分隔符渲染为树形结构。比如上面的例子，名称里的分隔符是 /，当然你也可以使用其他分隔符，比如 -、_ 等等。在夜莺的菜单 系统配置-站点设置 里，可以设置业务组展示模式和分隔符。
🟢 推荐使用 / 作为分隔符。
问题 # 在夜莺里，业务组是全局共享的，既可以把规则挂到业务组上，也可以把机器挂到业务组上，这有个好处，就是方便复用业务组，即业务组创建一次之后，在多个地方都可以使用。
但是这样做也有一个问题，那就是不同的东西，其分组的颗粒度是不同的。比如我们对机器分组的话，可能会分的比较细，比如：
DBA/MySQL/Proxy/RegionA DBA/MySQL/Proxy/RegionB 但当我们对告警规则、仪表盘这些东西分组的时候，可能就不会分的那么细了，比如 DBA 所有的仪表盘，可能全部放在 DBA 下面就好了。</description></item><item><title>Webhook(Callback)</title><link>https://n9e.github.io/zh/docs/usecase/webhook/</link><pubDate>Fri, 06 Jun 2025 10:54:48 +0800</pubDate><guid>https://n9e.github.io/zh/docs/usecase/webhook/</guid><description>本文讲解夜莺 v8.beta13 以上版本的 Webhook(Callback) 相关能力。Webhook 通常用在两个场景：
与夜莺联动事件自动化处理： 事件触发后，夜莺可以通过 Webhook 通知外部系统，外部系统可以根据事件内容进行自动化处理。 事件触发后，夜莺可以通过 Webhook 通知外部系统，外部系统对事件做修改，然后把事件返回，继续在夜莺中处理。相当于外部系统充当了夜莺的事件处理器。 与夜莺联动事件通知： 事件触发后，夜莺可以通过 Webhook 通知外部系统，外部系统可以根据事件内容进行告警通知，即外部系统仅充当一个通知媒介。 下面我们分别对这两种场景进行讲解演示。
与夜莺联动事件自动化处理 # 需要新建一个“通知规则” 在“通知规则”里，添加事件处理器，事件处理器需要提前创建好，使用 Callback 类型的处理器，创建处理器的页面举例如下。 这里的 http://10.99.1.107:8888/print 是我的一个测试程序，可以把接收到的 HTTP 请求打印出来，方便演示。这个程序也是一个开源小程序，地址在 github gohttpd。
创建了处理器后，回到通知规则页面，添加事件处理器，选择刚才创建的处理器。
接下来，就可以去配置“告警规则”做测试了，测试一下产生的告警能否被第三方程序接收到。
为了尽快看到效果，可以创建一个肯定会触发阈值的告警规则，然后在通知规则那里，选择刚才创建的通知规则：
稍等片刻，去观察 http://10.99.1.107:8888/print 这个程序是否收到回调的 HTTP 请求。我的环境里看到的结果如下：
从上图可以看出，HTTP request 中包含了告警事件的信息，其内容如下：
{ &amp;quot;id&amp;quot;: 1097371, &amp;quot;cate&amp;quot;: &amp;quot;prometheus&amp;quot;, &amp;quot;cluster&amp;quot;: &amp;quot;prom&amp;quot;, &amp;quot;datasource_id&amp;quot;: 1, &amp;quot;group_id&amp;quot;: 2, &amp;quot;group_name&amp;quot;: &amp;quot;DBA-Postgres&amp;quot;, &amp;quot;hash&amp;quot;: &amp;quot;54f5543591c6dc0e30139cae196a1eee&amp;quot;, &amp;quot;rule_id&amp;quot;: 54, &amp;quot;rule_name&amp;quot;: &amp;quot;测试事件回调&amp;quot;, &amp;quot;rule_note&amp;quot;: &amp;quot;&amp;quot;, &amp;quot;rule_prod&amp;quot;: &amp;quot;metric&amp;quot;, &amp;quot;rule_algo&amp;quot;: &amp;quot;&amp;quot;, &amp;quot;severity&amp;quot;: 2, &amp;quot;prom_for_duration&amp;quot;: 0, &amp;quot;prom_ql&amp;quot;: &amp;quot;cpu_usage_active{ident=\&amp;quot;ulric-flashcat.</description></item></channel></rss>
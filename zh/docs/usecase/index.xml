<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>功能详解 on</title><link>https://n9e.github.io/zh/docs/usecase/</link><description>Recent content in 功能详解 on</description><generator>Hugo -- gohugo.io</generator><language>en-US</language><lastBuildDate>Fri, 06 Jun 2025 10:41:08 +0800</lastBuildDate><atom:link href="https://n9e.github.io/zh/docs/usecase/index.xml" rel="self" type="application/rss+xml"/><item><title>告警原理和流程说明</title><link>https://n9e.github.io/zh/docs/usecase/alerting/</link><pubDate>Mon, 23 Jun 2025 11:00:09 +0800</pubDate><guid>https://n9e.github.io/zh/docs/usecase/alerting/</guid><description>夜莺监控（Nightingale）的功能侧重点是告警引擎，为了做得灵活，整个告警流程涉及到的功能点比较多，本文从原理和数据流的角度，介绍一下相关知识，理解这些知识，对于您使用夜莺、排查告警问题，都会有帮助。
数据流原理概述 # 用户在 Web UI 配置告警规则，规则保存在 DB 中（通常是 MySQL）。 告警引擎（n9e 进程内置一个告警引擎，边缘模式下 n9e-edge 进程里也内置告警引擎）从 DB 同步告警规则到内存中（通常 n9e-edge 无法直接读 DB，是调用的中心端 n9e 的接口获取的告警规则）。 告警引擎会为每条告警规则创建一个 goroutine（协程，姑且可以理解为轻量级线程），按照用户在告警规则里配置的频率，周期性查询存储，对数据做异常判定，最终生成告警事件。 产生告警事件后，要先持久化到 DB 中（通常是 MySQL），然后再走后面的通知规则。 通知规则包含两部分，一个是若干事件处理器（比如 relabel、event update、event drop、ai summary 等），另一个是若干告警通知配置（比如 Critical 的告警事件关联电话、短信通知媒介，Warning 的告警事件只关联邮件媒介）。 告警规则 # 告警规则核心就是配置一个查询条件，比如 Prometheus 数据源就是配置 PromQL，ClickHouse 数据源就是配置 SQL，然后再配置一个阈值（Prometheus 场景下，阈值包含在 PromQL 中，不需要单独配置），达到阈值并满足持续时长，就告警。
告警引擎针对每条规则创建一个 goroutine（协程），周期性地查询数据源，判断是否满足告警条件。以 Prometheus 数据源举例，其原理是：
夜莺周期性调用数据源的 /api/v1/query 接口，把当前时间和 PromQL 作为查询条件传给这个接口。 数据源如果返回多条记录，大概率就要生成多条告警事件，接下来要看持续时长，如果持续时长为 0，立马生成告警事件，如果持续时长大于 0，就要把这条记录放到一个缓存中，等到持续时长满足条件后，再生成告警事件，在持续时长过程中，如果后面的执行周期查不到数据了，就会把这条记录从缓存中删除，也就不会生成告警事件了。 这里经常遇到的问题是，告警引擎在查询的时候没有查到数据，故而无法生成告警事件，但是后面排查的时候发现那个时间点却是有数据满足阈值的，百思不得其解，这种情况，可能的原因有两个：
因为监控数据的上报有延迟导致的，在这里夜莺只是一个 client，数据源是 server，数据源没有返回数据，就要去看 server 侧的问题，看 server 侧的数据为啥没有返回，通常是数据有各种因素延迟了。 查询超时了，日志文件里通常可以看到相关日志，可以在数据源配置页面调大查询超时时间，或者排查数据源为啥返回慢了，另外硬件方面也可能有问题，比如 client、server 两边是否有网卡丢包。超时的日志，可以检索关键字：alert-${datasource-id}-${alert-rule-id} 其中：</description></item><item><title>业务组</title><link>https://n9e.github.io/zh/docs/usecase/bizgroup/</link><pubDate>Fri, 13 Jun 2025 10:14:48 +0800</pubDate><guid>https://n9e.github.io/zh/docs/usecase/bizgroup/</guid><description>夜莺中要管理很多东西，比如：告警规则、屏蔽规则、订阅规则、自愈脚本、仪表盘，在创建这些东西的时候，都要先选择一个业务组，因为这些东西都要归属到某个业务组。还有机器也是，安装了 categraf 之后，categraf 就会自动向夜莺注册机器信息，此时这个机器会出现在未归组机器列表种，管理员需要把这个机器归到某个业务组下，业务组的人才能使用。
业务组在夜莺中使用频繁，本篇讲解夜莺监控中的业务组的概念，以及相关的设计初衷。
需求来源 # 夜莺中要管理很多东西，比如：告警规则、屏蔽规则、订阅规则、自愈脚本、机器等。如果各个东西都放在一个表格里让大家查看、管理，那就比较混乱了，需要有个机制来分门别类。
于是，我们引入了“业务组”的概念。业务组就是一个分组机制，比如 DBA 把 MySQL 的告警规则放到一个业务组里（组名姑且叫 DBA/MySQL），把 Postgres 的告警规则放到另一个业务组里（组名姑且叫 DBA/Postgres）；比如 Kubernetes 运维人员，按照集群对 Kubernetes 的宿主机做了拆分，不同的集群的机器放到不同的业务组下，比如分成 K8S/集群A、K8S/集群B 等等。
演进 # 早期版本的夜莺，业务组渲染为扁平的列表，后来发现，其实业务组需要层级结构，比如上面的四个业务组：
DBA/MySQL DBA/Postgres K8S/集群A K8S/集群B 渲染为树形结构的话就更方便查看：
DBA ├── MySQL └── Postgres K8S ├── 集群A └── 集群B 所以新版本的夜莺，为了兼容老版本，业务组存储到 DB 的时候，仍然是扁平的列表，但在前端展示的时候，可以根据名称里的分隔符渲染为树形结构。比如上面的例子，名称里的分隔符是 /，当然你也可以使用其他分隔符，比如 -、_ 等等。在夜莺的菜单 系统配置-站点设置 里，可以设置业务组展示模式和分隔符。
🟢 推荐使用 / 作为分隔符。
问题 # 在夜莺里，业务组是全局共享的，既可以把规则挂到业务组上，也可以把机器挂到业务组上，这有个好处，就是方便复用业务组，即业务组创建一次之后，在多个地方都可以使用。
但是这样做也有一个问题，那就是不同的东西，其分组的颗粒度是不同的。比如我们对机器分组的话，可能会分的比较细，比如：
DBA/MySQL/Proxy/RegionA DBA/MySQL/Proxy/RegionB 但当我们对告警规则、仪表盘这些东西分组的时候，可能就不会分的那么细了，比如 DBA 所有的仪表盘，可能全部放在 DBA 下面就好了。</description></item><item><title>屏蔽规则</title><link>https://n9e.github.io/zh/docs/usecase/mute/</link><pubDate>Mon, 23 Jun 2025 16:50:43 +0800</pubDate><guid>https://n9e.github.io/zh/docs/usecase/mute/</guid><description>夜莺监控（Nightingale）中的屏蔽规则（菜单入口：告警-规则管理-屏蔽规则TAB）通常用于下面的场景：
提前屏蔽掉预期内的告警，典型的就是做一些维护动作，比如某个机器要重启，提前屏蔽这个机器相关的告警 有些问题急忙修复不了，已经知悉，持续告警通知也没意义，就先临时屏蔽掉 原理 # 告警事件经由告警引擎产生后，在持久化到 DB 之前，会先经过屏蔽规则的判断，如果匹配了屏蔽规则，就不会持久化到 DB，更无法通知用户。工作时机如下图：
屏蔽规则，本质上就是配置了一堆过滤条件，用于过滤想要屏蔽的告警事件。如何过滤呢，显然，就是根据告警事件的属性和标签来过滤。比如：
事件是哪个数据源产生的 事件的级别 事件的标签 比如下面的例子：
数据源类型：Prometheus，只有数据源类型是 Prometheus 的告警事件，才会被屏蔽 数据源：没配，表示不做限制 事件等级：三个级别都勾选了，表示所有级别的告警事件都要被屏蔽 事件标签：配置了两个标签，相当于：ident in (&amp;quot;10,1.2.3&amp;quot;, &amp;quot;10.1.2.4&amp;quot;) and rulename =~ &amp;quot;宕机&amp;quot; 上面所有的过滤条件，整体是and 的关系，即所有的条件都命中了某个事件，那个事件才会被屏蔽。
FAQ # 1. 我已经配置了屏蔽规则，相关告警事件为啥还是可以看到？
通常是因为：事件先产生了，才去配置的屏蔽规则。屏蔽规则是事后补救的，不能对已经产生的事件起作用。
2. 事件标签里的多个条件也是 and 关系，但是用户没有理解
如下图，用户在事件标签过滤那里，配置了两个条目，标签 key 都是 ident：
用户的本意是 10.1.2.113 和 10.1.2.114 这俩机器任意一台都要被屏蔽，但是事与愿违，这里是 and 的关系，相当于是：ident = &amp;quot;10.1.2.113&amp;quot; and ident = &amp;quot;10.1.2.114&amp;quot;，显然，这个条件永远不会命中任何事件。实际上，用户应该使用 in 操作符，如下所示：
3. 屏蔽规则的生效范围，仅限当前业务组
这个其实在页面上有提示。为了避免误操作，屏蔽规则的生效范围仅限当前业务组。也就是说，屏蔽规则只能屏蔽当前业务组下的告警事件，其他业务组下的告警事件不会受影响。
即：屏蔽规则和告警规则如果在不同业务组下，屏蔽规则不会对其生效。
如果屏蔽规则是全局生效的，就会比较危险，比如某个用户随便配置了一个告警规则，过滤条件可以匹配所有告警事件，那么公司所有的告警事件都会被屏蔽。</description></item><item><title>订阅规则</title><link>https://n9e.github.io/zh/docs/usecase/subscribe/</link><pubDate>Wed, 02 Jul 2025 08:51:08 +0800</pubDate><guid>https://n9e.github.io/zh/docs/usecase/subscribe/</guid><description>夜莺监控（Nightingale）中的订阅规则，其菜单入口在：告警-规则管理-订阅规则TAB。
为何有此设计 # 夜莺的告警规则中，可以直接配置通知规则，很直观，这个告警规则产生的告警事件就走这个通知规则。Datadog、Open-Falcon 都是类似这样的设计，基本是够用的。但是如果你了解 Zabbix、Prometheus，你会发现，它们产生告警事件之后，要发给谁，其实走的是一个后续订阅的逻辑，即：
告警规则中，只定义查询条件、阈值等，即告警规则仅是负责事件产生，至于如何通知、通知给谁，告警规则不管这些 用户使用订阅的机制，从所有告警事件中做筛选，对这些筛到的告警事件，指定相关的通知规则（通知给谁、如何通知） 这种方式实际上更灵活，缺点就是不够直观。夜莺呢？两种方式都支持，对于普通用户，优先建议使用“在告警规则中直接配置通知规则”的方式，把“订阅规则”，用在一些相对少见的场景，比如：
我的服务依赖了其他服务，这些服务不归我管（这些服务的告警规则通知给它们的负责人，而不是通知给我），但是这些服务如果故障，可能会影响我的服务，所以我希望订阅这些服务的 SLI 相关的告警事件（这是社区某些用户提到的需求场景，虽然写在这里，但是笔者实际不认可请你自行斟酌，笔者认为，每个服务都应该制作一个仪表盘，仪表盘里罗列了依赖的其他服务的 SLI 数据，自己的服务出故障时，应该统一去看这个仪表盘来判断是自身的问题还是依赖的下游服务的问题） 某些通用告警规则产生的告警事件，希望分发给不同的人，此时没法在告警规则中直接绑定通知规则，此时可以搭配订阅规则来实现 一些全局的操作，比如全局回调，可以通过订阅规则来实现。比如希望：对于系统产生的任何一条告警事件，都要回调某个 Webhook 地址，此时可以配置一个全局的订阅规则，匹配所有的告警事件，然后配置一个 Webhook 通知规则。 💡 请认真阅读上面这段文字，理解订阅规则的设计初衷。非常非常非常重要。
配置方法 # 订阅规则包含三部分配置：
名称：订阅规则的名称，建议使用有意义的名称，让别人一眼看到就知道这个订阅规则是干什么用的，方便维护 筛选配置：各个维度筛选告警事件，注意，是筛选告警事件，筛选到的这些告警事件，就会走下面的通知规则 通知规则：筛选到的告警事件，走这些通知规则 整体逻辑比较清晰，其中筛选配置的配置项较多，下面逐一介绍。
数据源类型：用于筛选告警事件是经由哪个数据源类型产生的 数据源：用于筛选告警事件是经由哪个数据源产生的 事件等级：用于筛选告警事件的级别，可以选择多个级别，默认全选，相当于 severity in (&amp;quot;Info&amp;quot;, &amp;quot;Warning&amp;quot;, &amp;quot;Critical&amp;quot;)，全选其实就相当于在“事件等级”这个维度上不做筛选过滤 订阅告警规则：用于筛选告警事件是哪个告警规则产生的 业务组：用于筛选告警事件是哪个业务组产生的，告警事件肯定是某个告警规则触发的，所以告警事件的业务组就是告警规则所属的业务组（当前版本是v8.0.0，后续会考虑优化这个地方，后续会同时考虑告警事件中的机器所属的业务组） 事件标签：用于筛选告警事件的标签，注意运算符的用法，具体解释放在下面 订阅事件持续时长：右侧有个小问号的 icon，提供了这个功能的使用说明，这里不再赘述。 上面的各个筛选条件，不同的条目之间整体是 and 的关系，其中事件标签这部分可以配置多个过滤条目，不同条目之间也是 and 的关系，如果你想匹配多个标签值，可以使用 in 操作符，或者使用正则表达式 =~。
对于运算符，具体解释如下：
== 匹配某个具体的标签值，只能填写一个，如果想同时匹配多个，应该使用 in 操作符 =~ 填写正则表达式，灵活匹配标签值 in 匹配多个标签值，类似 SQL 里的 in 操作 not in 不匹配的标签值，可填写多个，类似 SQL 里的 not in 操作，用于排除多个标签值 !</description></item><item><title>单点登录（SSO）</title><link>https://n9e.github.io/zh/docs/usecase/sso/</link><pubDate>Fri, 20 Jun 2025 08:16:11 +0800</pubDate><guid>https://n9e.github.io/zh/docs/usecase/sso/</guid><description>夜莺监控（Nightingale）支持单点登录（SSO）功能，支持 LDAP、CAS、OAuth2、OIDC 等多种协议。SSO 功能可以让用户通过统一的身份认证系统登录夜莺监控，简化用户管理和登录流程，也降低了安全风险。
对于 CAS、OAuth2、OIDC 三种方式，用户通过 SSO 登录夜莺之后，夜莺会判断当前登录的用户是否存在于夜莺的用户表中，如果不存在，则会自动创建一个用户，如果存在，夜莺会用 SSO 中的用户信息覆盖夜莺中已有用户的信息（前提是配置项 CoverAttributes = true，后文会介绍），这样的好处是用户只需要在 SSO 那里维护手机号、邮箱即可，夜莺会在用户登录时自动同步（当然，仅是在登录时同步，所以用户至少要通过 SSO 登录过一次夜莺，否则夜莺中没有这个用户的信息）。
配置 OIDC # 这是最推荐的方式，如果你的 SSO 同时支持 OIDC 和 OAuth2，建议使用 OIDC。
配置项说明 # 下面是 OIDC 各个配置项的说明：
# 是否开启 OIDC 单点登录，夜莺可以同时开启多个 SSO 方式 Enable = false # 登录页面会展示 SSO 登录地址的超链接，DisplayName 用于配置超链接的文本内容 DisplayName = 'OIDC' # IDC 登录验证通过后，需要跳转到夜莺，下面是配置夜莺用于 OIDC 的回调地址 # 您需要把 n9e.com 替换为您的夜莺地址，/callback 是固定的路径 RedirectURL = 'http://n9e.com/callback' # OIDC SSO 服务器根地址，换成您的 OIDC 服务器地址 SsoAddr = 'http://sso.</description></item><item><title>事件处理器 Pipeline</title><link>https://n9e.github.io/zh/docs/usecase/processor/</link><pubDate>Fri, 06 Jun 2025 10:54:48 +0800</pubDate><guid>https://n9e.github.io/zh/docs/usecase/processor/</guid><description>事件处理器（Event Processor）是夜莺 v8 版本引入的一个概念，当告警事件产生之后，在发送通知之前，可以使用事件处理器对告警事件做额外的处理，开源版本支持 Relabel、Callback、Event Update、Event Drop、AI Summary 5 类处理器，不同的处理器可以组成一个 Pipeline，对告警事件做一系列灵活的处理。场景比如：
跟内部的 CMDB 打通，附加一些更丰富的信息到告警事件上 调用 DeepSeek 的接口，对告警事件做一些智能分析，然后把分析结果附加到告警事件上 把所有告警事件发送到自己的系统，相当于镜像一份，做后续的分析处理 一些特定的告警事件可以 Drop 掉，比如一些恢复事件不想发送通知 这里涉及多个概念，通知规则、事件处理器（Processor）、事件处理管道（Pipeline），稍作解释：
一个通知规则里可以配置多个事件处理管道（Pipeline），顺序执行 一个事件处理管道（Pipeline）里可以配置多个事件处理器（Processor），也是顺序执行 上面的截图可以看出，入口菜单在 通知-通知规则，通知规则可能会有很多，在新增或编辑某个具体的通知规则时，可以看到有个 事件处理 的配置区域，这里可以引用多个提前创建好的事件管道（Pipeline），那在哪里对事件管道（Pipeline）增删改呢？入口比较隐藏，在 事件处理 右侧那个小齿轮里，点击可以展开一个侧拉板，在侧拉板里对事件管道（Pipeline）增删改。
创建、编辑事件管道（Pipeline）时，又会展开一个新的侧拉板，在这个新侧拉板里编辑 Pipeline，我们可以在 Pipeline 里配置多个事件处理器（Processor）：
点击事件处理器类型字段旁边的 使用说明 可以查看事件处理器的使用说明文档。
Relabel 处理器 # Relabel 处理器，类似 Prometheus 中对监控指标的 Relabel 操作，只不过夜莺这里，是对告警事件的 Relabel，告警事件里也有标签字段，也有需求对标签做一些加工处理，所以这里提供了 Relabel 处理器。
Relabel 处理器的具体使用说明，在夜莺的页面上点击事件处理器类型字段旁边的 使用说明，即可查看。
Callback 处理器 # 事件触发后，夜莺可以通过 Callback 通知外部系统，外部系统可以根据事件内容进行自动化处理。比如我见过有些公司自研了一套告警通知的系统，不用夜莺的通知机制，就直接把所有告警事件通过 Callback 处理器发送到自研的系统。
下面做一个简单的演示：
首先创建一个“通知规则”，因为 Callback 处理器属于某个 Pipeline，而 Pipeline 又属于某个通知规则。 在“通知规则”里，引用事件处理的 Pipeline，Pipeline 需要提前创建好（在通知规则编辑页面，点击处理器右侧的小齿轮打开侧拉板，在侧拉板里创建、编辑 Pipeline），下面截图是一个 Pipeline 的详情页面，里边有一个 Callback 处理器。 这里的 http://10.</description></item><item><title>自定义通知媒介</title><link>https://n9e.github.io/zh/docs/usecase/media/</link><pubDate>Thu, 03 Jul 2025 23:27:13 +0800</pubDate><guid>https://n9e.github.io/zh/docs/usecase/media/</guid><description>在阅读本节之前，请一定确保你已经阅读过《通知规则》章节的内容，而且《通知规则》章节中提到的那些外部链接资料，也都阅读过了。
下面我来模拟一个场景。假设我想使用企微应用（和企微机器人不是一个东西）来做告警通知，我们来捋一下整个流程。
基础配置 # 1、企微应用通知的时候，需要知道被通知的人的企微账号。夜莺里默认没有这个信息，我们可以自定义一个 wecomid 的联系方式的字段，然后各个用户自行配置一下。
上图中，wecomid 是我自定义的字段名，点击那个“联系方式管理”（只有管理员有权限），可以创建新的联系方式，这里我创建了一个新的联系方式叫 wecomid，用于配置各个用户的企微 ID。
2、创建一个自定义通知媒介，对应我自己的程序，当用户在夜莺里配置要发告警消息给这个通知媒介的时候，夜莺就会调用我的程序，我的程序就会去调用企微接口，使用企微应用的方式发送通知消息（当然，我这里不是实际发送，只是一个演示，仍然使用在 事件处理器 章节介绍的 gohttpd 小程序做演示）。
上图通知媒介的几个关键字段解释如下：
媒介类型：可以自定义，我这里随便取了个名字叫 wecomapp，通知媒介通常要和消息模板配合使用，只要消息模板的媒介类型也叫 wecomapp，媒介和消息模板就可以关联起来了。 联系方式：选择刚才创建的 wecomid 联系方式，这样夜莺在调用我的程序的时候，就会把告警接收人的企微ID传给我。 URL：我的程序的地址，夜莺会通过 HTTP POST 的方式调用这个地址，请求体的内容可以在下面定义。 请求体：用于定义回调的 HTTP request body 内容，可以引用几个变量，这个例子里我把三个关键变量都引用了 我的请求体：
{ &amp;quot;events&amp;quot;: {{ jsonMarshal $events }}, &amp;quot;sendtos&amp;quot;: {{ jsonMarshal $sendtos }}, &amp;quot;tpl&amp;quot;: {{ jsonMarshal $tpl }} } $events 是要发送的告警事件列表，虽然是个列表，实际开源版永远都只会有一条事件 $sendtos 是要发送给哪些接收者，最终是一个企微ID的列表，如果联系方式那里配置的是 Phone，这个 $sendtos 就是手机号列表 $tpl 是消息模板的内容，下面马上介绍 消息模板 # 最终在调用企微的接口发告警消息的时候，显然不是要把整个事件 JSON 发出来，那用户没法看。我们需要把事件格式化展示（比如 markdown 的方式），就像其他的通知媒介，都有对应的消息模板，自定义的通知媒介也需要有消息模板。下面我们就创建一个消息模板：</description></item><item><title>API</title><link>https://n9e.github.io/zh/docs/usecase/api/</link><pubDate>Fri, 13 Jun 2025 17:52:38 +0800</pubDate><guid>https://n9e.github.io/zh/docs/usecase/api/</guid><description>本文介绍如何使用 API 调用夜莺监控（Nightingale）的接口，主要是两类接口，一类是页面操作类，就是使用 API 模仿用户在页面上的操作，另一类是数据推送类，比如自己的程序采集了监控数据，想要推送给夜莺。
页面操作类 # 页面操作类的 API 主要是模拟用户在页面上的操作，比如创建告警规则、修改机器标签、修改机器备注、调整机器归属的业务组等。所有用户在页面上的操作，都可以使用 API 完成，您可以通过这些接口来实现自动化操作。
显然，要调用 API 需要有两个前提：
搞定认证 了解有哪些接口，各个接口有哪些参数 搞定认证 # 这里直接讲解 v8.0.0-beta.5 以上版本的认证方式，即个人中心 token 方式，这是最简单的方式。
1. 修改配置文件 # 修改夜莺的配置文件 etc/config.toml，确保配置了 HTTP.TokenAuth，并且设置了 Enable = true，如下所示：
... [HTTP.RSA] OpenRSA = false [HTTP.TokenAuth] Enable = true [DB] ... 2. 获取 Token # 登录夜莺监控，进入右上角头像，进入个人信息页面，点击 “Token 管理” 那个 Tab，然后点击“创建 Token”，随便起个名字，就可以得到一个 Token。
3. 使用 Token # 在调用 API 的时候，需要在 HTTP 请求的 Header 中添加 X-User-Token 字段，值为你刚才创建的 Token。用 cURL 命令调用 API 的示例：</description></item></channel></rss>
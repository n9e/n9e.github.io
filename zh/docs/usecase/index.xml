<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>功能详解 on</title><link>https://n9e.github.io/zh/docs/usecase/</link><description>Recent content in 功能详解 on</description><generator>Hugo -- gohugo.io</generator><language>en-US</language><lastBuildDate>Fri, 06 Jun 2025 10:41:08 +0800</lastBuildDate><atom:link href="https://n9e.github.io/zh/docs/usecase/index.xml" rel="self" type="application/rss+xml"/><item><title>告警原理和流程</title><link>https://n9e.github.io/zh/docs/usecase/alerting/</link><pubDate>Mon, 23 Jun 2025 11:00:09 +0800</pubDate><guid>https://n9e.github.io/zh/docs/usecase/alerting/</guid><description>夜莺监控（Nightingale）的功能侧重点是告警引擎，为了做得灵活，整个告警流程涉及到的功能点比较多，本文从原理和数据流的角度，介绍一下相关知识，理解这些知识，对于您使用夜莺、排查告警问题，都会有帮助。
数据流原理概述 # 用户在 Web UI 配置告警规则，规则保存在 DB 中（通常是 MySQL）。 告警引擎（n9e 进程内置一个告警引擎，边缘模式下 n9e-edge 进程里也内置告警引擎）从 DB 同步告警规则到内存中（通常 n9e-edge 无法直接读 DB，是调用的中心端 n9e 的接口获取的告警规则）。 告警引擎会为每条告警规则创建一个 goroutine（协程，姑且可以理解为轻量级线程），按照用户在告警规则里配置的频率，周期性查询存储，对数据做异常判定，最终生成告警事件。 产生告警事件后，要先持久化到 DB 中（通常是 MySQL），然后再走后面的通知规则。 通知规则包含两部分，一个是若干事件处理器（比如 relabel、event update、event drop、ai summary 等），另一个是若干告警通知配置（比如 Critical 的告警事件关联电话、短信通知媒介，Warning 的告警事件只关联邮件媒介）。 告警规则 # 告警规则核心就是配置一个查询条件，比如 Prometheus 数据源就是配置 PromQL，ClickHouse 数据源就是配置 SQL，然后再配置一个阈值（Prometheus 场景下，阈值包含在 PromQL 中，不需要单独配置），达到阈值并满足持续时长，就告警。
告警引擎针对每条规则创建一个 goroutine（协程），周期性地查询数据源，判断是否满足告警条件。以 Prometheus 数据源举例，其原理是：
夜莺周期性调用数据源的 /api/v1/query 接口，把当前时间和 PromQL 作为查询条件传给这个接口。 数据源如果返回多条记录，大概率就要生成多条告警事件，接下来要看持续时长，如果持续时长为 0，立马生成告警事件，如果持续时长大于 0，就要把这条记录放到一个缓存中，等到持续时长满足条件后，再生成告警事件，在持续时长过程中，如果后面的执行周期查不到数据了，就会把这条记录从缓存中删除，也就不会生成告警事件了。 这里经常遇到的问题是，告警引擎在查询的时候没有查到数据，故而无法生成告警事件，但是后面排查的时候发现那个时间点却是有数据满足阈值的，百思不得其解，这种情况，可能的原因有两个：
因为监控数据的上报有延迟导致的，在这里夜莺只是一个 client，数据源是 server，数据源没有返回数据，就要去看 server 侧的问题，看 server 侧的数据为啥没有返回，通常是数据有各种因素延迟了。 查询超时了，日志文件里通常可以看到相关日志，可以在数据源配置页面调大查询超时时间，或者排查数据源为啥返回慢了，另外硬件方面也可能有问题，比如 client、server 两边是否有网卡丢包。超时的日志，可以检索关键字：alert-${datasource-id}-${alert-rule-id} 其中：</description></item><item><title>业务组</title><link>https://n9e.github.io/zh/docs/usecase/bizgroup/</link><pubDate>Fri, 13 Jun 2025 10:14:48 +0800</pubDate><guid>https://n9e.github.io/zh/docs/usecase/bizgroup/</guid><description>夜莺中要管理很多东西，比如：告警规则、屏蔽规则、订阅规则、自愈脚本、仪表盘，在创建这些东西的时候，都要先选择一个业务组，因为这些东西都要归属到某个业务组。还有机器也是，安装了 categraf 之后，categraf 就会自动向夜莺注册机器信息，此时这个机器会出现在未归组机器列表种，管理员需要把这个机器归到某个业务组下，业务组的人才能使用。
业务组在夜莺中使用频繁，本篇讲解夜莺监控中的业务组的概念，以及相关的设计初衷。
需求来源 # 夜莺中要管理很多东西，比如：告警规则、屏蔽规则、订阅规则、自愈脚本、机器等。如果各个东西都放在一个表格里让大家查看、管理，那就比较混乱了，需要有个机制来分门别类。
于是，我们引入了“业务组”的概念。业务组就是一个分组机制，比如 DBA 把 MySQL 的告警规则放到一个业务组里（组名姑且叫 DBA/MySQL），把 Postgres 的告警规则放到另一个业务组里（组名姑且叫 DBA/Postgres）；比如 Kubernetes 运维人员，按照集群对 Kubernetes 的宿主机做了拆分，不同的集群的机器放到不同的业务组下，比如分成 K8S/集群A、K8S/集群B 等等。
演进 # 早期版本的夜莺，业务组渲染为扁平的列表，后来发现，其实业务组需要层级结构，比如上面的四个业务组：
DBA/MySQL DBA/Postgres K8S/集群A K8S/集群B 渲染为树形结构的话就更方便查看：
DBA ├── MySQL └── Postgres K8S ├── 集群A └── 集群B 所以新版本的夜莺，为了兼容老版本，业务组存储到 DB 的时候，仍然是扁平的列表，但在前端展示的时候，可以根据名称里的分隔符渲染为树形结构。比如上面的例子，名称里的分隔符是 /，当然你也可以使用其他分隔符，比如 -、_ 等等。在夜莺的菜单 系统配置-站点设置 里，可以设置业务组展示模式和分隔符。
🟢 推荐使用 / 作为分隔符。
问题 # 在夜莺里，业务组是全局共享的，既可以把规则挂到业务组上，也可以把机器挂到业务组上，这有个好处，就是方便复用业务组，即业务组创建一次之后，在多个地方都可以使用。
但是这样做也有一个问题，那就是不同的东西，其分组的颗粒度是不同的。比如我们对机器分组的话，可能会分的比较细，比如：
DBA/MySQL/Proxy/RegionA DBA/MySQL/Proxy/RegionB 但当我们对告警规则、仪表盘这些东西分组的时候，可能就不会分的那么细了，比如 DBA 所有的仪表盘，可能全部放在 DBA 下面就好了。</description></item><item><title>单点登录（SSO）</title><link>https://n9e.github.io/zh/docs/usecase/sso/</link><pubDate>Fri, 20 Jun 2025 08:16:11 +0800</pubDate><guid>https://n9e.github.io/zh/docs/usecase/sso/</guid><description>夜莺监控（Nightingale）支持单点登录（SSO）功能，支持 LDAP、CAS、OAuth2、OIDC 等多种协议。SSO 功能可以让用户通过统一的身份认证系统登录夜莺监控，简化用户管理和登录流程，也降低了安全风险。
对于 CAS、OAuth2、OIDC 三种方式，用户通过 SSO 登录夜莺之后，夜莺会判断当前登录的用户是否存在于夜莺的用户表中，如果不存在，则会自动创建一个用户，如果存在，夜莺会用 SSO 中的用户信息覆盖夜莺中已有用户的信息（前提是配置项 CoverAttributes = true，后文会介绍），这样的好处是用户只需要在 SSO 那里维护手机号、邮箱即可，夜莺会在用户登录时自动同步（当然，仅是在登录时同步，所以用户至少要通过 SSO 登录过一次夜莺，否则夜莺中没有这个用户的信息）。
配置 OIDC # 这是最推荐的方式，如果你的 SSO 同时支持 OIDC 和 OAuth2，建议使用 OIDC。
配置项说明 # 下面是 OIDC 各个配置项的说明：
# 是否开启 OIDC 单点登录，夜莺可以同时开启多个 SSO 方式 Enable = false # 登录页面会展示 SSO 登录地址的超链接，DisplayName 用于配置超链接的文本内容 DisplayName = 'OIDC' # IDC 登录验证通过后，需要跳转到夜莺，下面是配置夜莺用于 OIDC 的回调地址 # 您需要把 n9e.com 替换为您的夜莺地址，/callback 是固定的路径 RedirectURL = 'http://n9e.com/callback' # OIDC SSO 服务器根地址，换成您的 OIDC 服务器地址 SsoAddr = 'http://sso.</description></item><item><title>Webhook(Callback)</title><link>https://n9e.github.io/zh/docs/usecase/webhook/</link><pubDate>Fri, 06 Jun 2025 10:54:48 +0800</pubDate><guid>https://n9e.github.io/zh/docs/usecase/webhook/</guid><description>本文讲解夜莺 v8.beta13 以上版本的 Webhook(Callback) 相关能力。Webhook 通常用在两个场景：
与夜莺联动事件自动化处理： 事件触发后，夜莺可以通过 Webhook 通知外部系统，外部系统可以根据事件内容进行自动化处理。 事件触发后，夜莺可以通过 Webhook 通知外部系统，外部系统对事件做修改，然后把事件返回，继续在夜莺中处理。相当于外部系统充当了夜莺的事件处理器。 与夜莺联动事件通知： 事件触发后，夜莺可以通过 Webhook 通知外部系统，外部系统可以根据事件内容进行告警通知，即外部系统仅充当一个通知媒介。 下面我们分别对这两种场景进行讲解演示。
与夜莺联动事件自动化处理 # 需要新建一个“通知规则” 在“通知规则”里，添加事件处理器，事件处理器需要提前创建好，使用 Callback 类型的处理器，创建处理器的页面举例如下。 这里的 http://10.99.1.107:8888/print 是我的一个测试程序，可以把接收到的 HTTP 请求打印出来，方便演示。这个程序也是一个开源小程序，地址在 github gohttpd。
创建了处理器后，回到通知规则页面，添加事件处理器，选择刚才创建的处理器。
接下来，就可以去配置“告警规则”做测试了，测试一下产生的告警能否被第三方程序接收到。
为了尽快看到效果，可以创建一个肯定会触发阈值的告警规则，然后在通知规则那里，选择刚才创建的通知规则：
稍等片刻，去观察 http://10.99.1.107:8888/print 这个程序是否收到回调的 HTTP 请求。我的环境里看到的结果如下：
从上图可以看出，HTTP request 中包含了告警事件的信息，其内容如下：
{ &amp;quot;id&amp;quot;: 1097371, &amp;quot;cate&amp;quot;: &amp;quot;prometheus&amp;quot;, &amp;quot;cluster&amp;quot;: &amp;quot;prom&amp;quot;, &amp;quot;datasource_id&amp;quot;: 1, &amp;quot;group_id&amp;quot;: 2, &amp;quot;group_name&amp;quot;: &amp;quot;DBA-Postgres&amp;quot;, &amp;quot;hash&amp;quot;: &amp;quot;54f5543591c6dc0e30139cae196a1eee&amp;quot;, &amp;quot;rule_id&amp;quot;: 54, &amp;quot;rule_name&amp;quot;: &amp;quot;测试事件回调&amp;quot;, &amp;quot;rule_note&amp;quot;: &amp;quot;&amp;quot;, &amp;quot;rule_prod&amp;quot;: &amp;quot;metric&amp;quot;, &amp;quot;rule_algo&amp;quot;: &amp;quot;&amp;quot;, &amp;quot;severity&amp;quot;: 2, &amp;quot;prom_for_duration&amp;quot;: 0, &amp;quot;prom_ql&amp;quot;: &amp;quot;cpu_usage_active{ident=\&amp;quot;ulric-flashcat.</description></item><item><title>API</title><link>https://n9e.github.io/zh/docs/usecase/api/</link><pubDate>Fri, 13 Jun 2025 17:52:38 +0800</pubDate><guid>https://n9e.github.io/zh/docs/usecase/api/</guid><description>本文介绍如何使用 API 调用夜莺监控（Nightingale）的接口，主要是两类接口，一类是页面操作类，就是使用 API 模仿用户在页面上的操作，另一类是数据推送类，比如自己的程序采集了监控数据，想要推送给夜莺。
页面操作类 # 页面操作类的 API 主要是模拟用户在页面上的操作，比如创建告警规则、修改机器标签、修改机器备注、调整机器归属的业务组等。所有用户在页面上的操作，都可以使用 API 完成，您可以通过这些接口来实现自动化操作。
显然，要调用 API 需要有两个前提：
搞定认证 了解有哪些接口，各个接口有哪些参数 搞定认证 # 这里直接讲解 v8.0.0-beta.5 以上版本的认证方式，即个人中心 token 方式，这是最简单的方式。
1. 修改配置文件 # 修改夜莺的配置文件 etc/config.toml，确保配置了 HTTP.TokenAuth，并且设置了 Enable = true，如下所示：
... [HTTP.RSA] OpenRSA = false [HTTP.TokenAuth] Enable = true [DB] ... 2. 获取 Token # 登录夜莺监控，进入右上角头像，进入个人信息页面，点击 “Token 管理” 那个 Tab，然后点击“创建 Token”，随便起个名字，就可以得到一个 Token。
3. 使用 Token # 在调用 API 的时候，需要在 HTTP 请求的 Header 中添加 X-User-Token 字段，值为你刚才创建的 Token。用 cURL 命令调用 API 的示例：</description></item></channel></rss>
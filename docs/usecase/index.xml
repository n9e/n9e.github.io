<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Use Case on</title><link>https://n9e.github.io/docs/usecase/</link><description>Recent content in Use Case on</description><generator>Hugo -- gohugo.io</generator><language>en-US</language><lastBuildDate>Fri, 06 Jun 2025 10:41:08 +0800</lastBuildDate><atom:link href="https://n9e.github.io/docs/usecase/index.xml" rel="self" type="application/rss+xml"/><item><title>Alerting Principles and Process Explanation</title><link>https://n9e.github.io/docs/usecase/alerting/</link><pubDate>Sat, 26 Jul 2025 17:17:11 +0800</pubDate><guid>https://n9e.github.io/docs/usecase/alerting/</guid><description>The key feature of Nightingale monitoring is its alerting engine. To achieve flexibility, the entire alerting process involves multiple functional points. This article introduces relevant knowledge from the perspective of principles and data flow, which will be helpful for you to use Nightingale and troubleshoot alerting issues.
Overview of Data Flow Principles # Users configure alert rules in the Web UI, and the rules are stored in the DB (usually MySQL).</description></item><item><title>Business Groups</title><link>https://n9e.github.io/docs/usecase/bizgroup/</link><pubDate>Sat, 26 Jul 2025 17:17:34 +0800</pubDate><guid>https://n9e.github.io/docs/usecase/bizgroup/</guid><description>Nightingale needs to manage many things, such as: alert rules, shielding rules, subscription rules, self-healing scripts, dashboards. When creating these things, you must first select a business group because these things must belong to a certain business group. The same goes for machines. After installing categraf, categraf will automatically register machine information with Nightingale. At this time, the machine will appear in the list of ungrouped machines. Administrators need to assign the machine to a certain business group so that members of the business group can use it.</description></item><item><title>Muting Rules</title><link>https://n9e.github.io/docs/usecase/mute/</link><pubDate>Sat, 26 Jul 2025 17:17:52 +0800</pubDate><guid>https://n9e.github.io/docs/usecase/mute/</guid><description>Muting rules in Nightingale monitoring (menu entry: Alerts - Rule Management - Muting Rules TAB) are typically used in the following scenarios:
To pre-block expected alerts, typically during maintenance activities, such as restarting a machine and pre-muting alerts related to that machine in advance For issues that cannot be fixed immediately but are already known; continuous alert notifications are unnecessary, so temporary muting is applied Principle # After an alert event is generated by the alert engine, it will first go through the judgment of muting rules before being persisted to the database.</description></item><item><title>Subscription Rules</title><link>https://n9e.github.io/docs/usecase/subscribe/</link><pubDate>Sat, 26 Jul 2025 17:18:19 +0800</pubDate><guid>https://n9e.github.io/docs/usecase/subscribe/</guid><description>The subscription rules in Nightingale monitoring can be accessed through the menu: Alerts - Rule Management - Subscription Rules TAB.
Why This Design # In Nightingale&amp;rsquo;s alert rules, you can directly configure notification rules, which is very intuitive. Alert events generated by this alert rule will follow this notification rule. Datadog and Open-Falcon have similar designs, which are basically sufficient. However, if you are familiar with Zabbix and Prometheus, you will find that after an alert event is generated, who it is sent to actually follows a subsequent subscription logic:</description></item><item><title>Event Processor</title><link>https://n9e.github.io/docs/usecase/processor/</link><pubDate>Sat, 26 Jul 2025 17:18:01 +0800</pubDate><guid>https://n9e.github.io/docs/usecase/processor/</guid><description>Event Processor is a concept introduced in Nightingale v8. After an alert event is generated, before sending notifications, Event Processors can be used to perform additional processing on the alert event. The open-source version supports 5 types of processors: Relabel, Callback, Event Update, Event Drop, and AI Summary. Different processors can form a Pipeline to perform a series of flexible processing on alert events. Examples of scenarios include:
Integrating with internal CMDB to attach more abundant information to alert events Calling DeepSeek&amp;rsquo;s API to perform intelligent analysis on alert events and attach the analysis results to the alert events Sending all alert events to your own system, which is equivalent to mirroring a copy for subsequent analysis and processing Dropping some specific alert events, such as some recovery events that you don&amp;rsquo;t want to send notifications for Several concepts are involved here: notification rules, event processors, and event processing pipelines.</description></item><item><title>Custom Notification Media</title><link>https://n9e.github.io/docs/usecase/media/</link><pubDate>Sat, 26 Jul 2025 17:17:44 +0800</pubDate><guid>https://n9e.github.io/docs/usecase/media/</guid><description>Before reading this section, please ensure that you have read the content of the &amp;ldquo;Notification Rules&amp;rdquo; chapter, and also reviewed the external link materials mentioned in the &amp;ldquo;Notification Rules&amp;rdquo; chapter.
Let&amp;rsquo;s simulate a scenario. Suppose I want to use a WeCom application (not the same as WeCom robot) for alarm notifications. Let&amp;rsquo;s go through the entire process.
Basic Configuration # When sending notifications via a WeCom application, we need to know the WeCom account of the person being notified.</description></item><item><title>Single Sign-On (SSO)</title><link>https://n9e.github.io/docs/usecase/sso/</link><pubDate>Sat, 26 Jul 2025 17:18:11 +0800</pubDate><guid>https://n9e.github.io/docs/usecase/sso/</guid><description>Nightingale monitoring supports Single Sign-On (SSO) functionality, including multiple protocols such as LDAP, CAS, OAuth2, OIDC, etc. The SSO feature allows users to log in to Nightingale monitoring through a unified identity authentication system, simplifying user management and login processes while reducing security risks.
For CAS, OAuth2, and OIDC methods, after a user logs in to Nightingale via SSO, Nightingale will check if the currently logged-in user exists in Nightingale&amp;rsquo;s user table.</description></item><item><title>API</title><link>https://n9e.github.io/docs/usecase/api/</link><pubDate>Sat, 26 Jul 2025 17:17:24 +0800</pubDate><guid>https://n9e.github.io/docs/usecase/api/</guid><description>This article introduces how to use API to call the interfaces of Nightingale monitoring system. There are mainly two types of interfaces: one is page operation interface, which imitates user operations on the page through API, and the other is data push interface, for example, if your own program collects monitoring data and wants to push it to Nightingale.
Page Operation Interfaces # Page operation interfaces mainly simulate user operations on the page, such as creating alarm rules, modifying machine tags, modifying machine remarks, adjusting the business group that the machine belongs to, etc.</description></item></channel></rss>